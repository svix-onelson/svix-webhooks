/*
 * Svix API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.1.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use crate::Configuration;
use crate::models;
use crate::error::Error;
#[allow(unused_imports)]
use crate::models::*;

/// struct for passing parameters to the method [`get_app_usage_stats_api_v1_app_stats_usage_get`]
#[derive(Clone, Debug)]
pub struct GetAppUsageStatsApiV1AppStatsUsageGetParams {
    /// Filter the range to data after this date.
    pub since: String,
    /// Filter the range to data before this date.
    pub until: String,
    /// Limit the number of returned items.
    pub limit: Option<i32>,
    /// The iterator to use (depends on the chosen ordering).
    pub iterator: Option<String>
}

/// struct for passing parameters to the method [`v1_period_application_period_create`]
#[derive(Clone, Debug)]
pub struct V1PeriodApplicationPeriodCreateParams {
    pub application_in: models::ApplicationIn,
    /// Get an existing application, or create a new one if doesn't exist. It's two separate functions in the libs.
    pub get_if_exists: Option<bool>,
    /// The request's idempotency key
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`v1_period_application_period_delete`]
#[derive(Clone, Debug)]
pub struct V1PeriodApplicationPeriodDeleteParams {
    /// The app's ID or UID
    pub app_id: String
}

/// struct for passing parameters to the method [`v1_period_application_period_get`]
#[derive(Clone, Debug)]
pub struct V1PeriodApplicationPeriodGetParams {
    /// The app's ID or UID
    pub app_id: String
}

/// struct for passing parameters to the method [`v1_period_application_period_get_stats`]
#[derive(Clone, Debug)]
pub struct V1PeriodApplicationPeriodGetStatsParams {
    /// Filter the range to data starting from this date.
    pub since: String,
    /// Filter the range to data ending by this date.
    pub until: String,
    /// The app's ID or UID
    pub app_id: String
}

/// struct for passing parameters to the method [`v1_period_application_period_list`]
#[derive(Clone, Debug)]
pub struct V1PeriodApplicationPeriodListParams {
    /// Limit the number of returned items
    pub limit: Option<i32>,
    /// The iterator returned from a prior invocation
    pub iterator: Option<String>,
    /// The sorting order of the returned items
    pub order: Option<Ordering>
}

/// struct for passing parameters to the method [`v1_period_application_period_patch`]
#[derive(Clone, Debug)]
pub struct V1PeriodApplicationPeriodPatchParams {
    /// The app's ID or UID
    pub app_id: String,
    pub application_patch: models::ApplicationPatch
}

/// struct for passing parameters to the method [`v1_period_application_period_update`]
#[derive(Clone, Debug)]
pub struct V1PeriodApplicationPeriodUpdateParams {
    /// The app's ID or UID
    pub app_id: String,
    pub application_in: models::ApplicationIn
}


/// struct for typed errors of method [`get_app_usage_stats_api_v1_app_stats_usage_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAppUsageStatsApiV1AppStatsUsageGetError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_application_period_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodApplicationPeriodCreateError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_application_period_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodApplicationPeriodDeleteError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_application_period_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodApplicationPeriodGetError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_application_period_get_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodApplicationPeriodGetStatsError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_application_period_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodApplicationPeriodListError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_application_period_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodApplicationPeriodPatchError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_application_period_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodApplicationPeriodUpdateError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}


/// Get basic statistics for all applications.
pub async fn get_app_usage_stats_api_v1_app_stats_usage_get(configuration: &Configuration, params: GetAppUsageStatsApiV1AppStatsUsageGetParams) -> Result<models::ListResponseApplicationStats, Error> {
    // unbox the parameters
    let since = params.since;
    let until = params.until;
    let limit = params.limit;
    let iterator = params.iterator;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/app/stats/usage".to_string())
    ;
    req = req.with_query_param("since".to_string(), since.to_string());
    req = req.with_query_param("until".to_string(), until.to_string());
    if let Some(ref s) = limit {
        let query_value = s.to_string();
        req = req.with_query_param("limit".to_string(), query_value);
    }
    if let Some(ref s) = iterator {
        let query_value = s.to_string();
        req = req.with_query_param("iterator".to_string(), query_value);
    }

    req.execute(configuration).await
}

/// Create a new application.
pub async fn v1_period_application_period_create(configuration: &Configuration, params: V1PeriodApplicationPeriodCreateParams) -> Result<models::ApplicationOut, Error> {
    // unbox the parameters
    let application_in = params.application_in;
    let get_if_exists = params.get_if_exists;
    let idempotency_key = params.idempotency_key;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::POST, "/api/v1/app".to_string())
    ;
    if let Some(ref s) = get_if_exists {
        let query_value = s.to_string();
        req = req.with_query_param("get_if_exists".to_string(), query_value);
    }
    if let Some(param_value) = idempotency_key {
        req = req.with_header_param("idempotency-key".to_string(), param_value.to_string());
    }
    req = req.with_body_param(application_in);

    req.execute(configuration).await
}

/// Delete an application.
pub async fn v1_period_application_period_delete(configuration: &Configuration, params: V1PeriodApplicationPeriodDeleteParams) -> Result<(), Error> {
    // unbox the parameters
    let app_id = params.app_id;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::DELETE, "/api/v1/app/{app_id}".to_string())
    ;
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.returns_nothing();

    req.execute(configuration).await
}

/// Get an application.
pub async fn v1_period_application_period_get(configuration: &Configuration, params: V1PeriodApplicationPeriodGetParams) -> Result<models::ApplicationOut, Error> {
    // unbox the parameters
    let app_id = params.app_id;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/app/{app_id}".to_string())
    ;
    req = req.with_path_param("app_id".to_string(), app_id.to_string());

    req.execute(configuration).await
}

/// Get basic statistics for the application.
pub async fn v1_period_application_period_get_stats(configuration: &Configuration, params: V1PeriodApplicationPeriodGetStatsParams) -> Result<models::ApplicationStats, Error> {
    // unbox the parameters
    let since = params.since;
    let until = params.until;
    let app_id = params.app_id;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/app/{app_id}/stats".to_string())
    ;
    req = req.with_query_param("since".to_string(), since.to_string());
    req = req.with_query_param("until".to_string(), until.to_string());
    req = req.with_path_param("app_id".to_string(), app_id.to_string());

    req.execute(configuration).await
}

/// List of all the organization's applications.
pub async fn v1_period_application_period_list(configuration: &Configuration, params: V1PeriodApplicationPeriodListParams) -> Result<models::ListResponseApplicationOut, Error> {
    // unbox the parameters
    let limit = params.limit;
    let iterator = params.iterator;
    let order = params.order;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/app".to_string())
    ;
    if let Some(ref s) = limit {
        let query_value = s.to_string();
        req = req.with_query_param("limit".to_string(), query_value);
    }
    if let Some(ref s) = iterator {
        let query_value = s.to_string();
        req = req.with_query_param("iterator".to_string(), query_value);
    }
    if let Some(ref s) = order {
        let query_value = s.to_string();
        req = req.with_query_param("order".to_string(), query_value);
    }

    req.execute(configuration).await
}

/// Partially update an application.
pub async fn v1_period_application_period_patch(configuration: &Configuration, params: V1PeriodApplicationPeriodPatchParams) -> Result<models::ApplicationOut, Error> {
    // unbox the parameters
    let app_id = params.app_id;
    let application_patch = params.application_patch;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::PATCH, "/api/v1/app/{app_id}".to_string())
    ;
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.with_body_param(application_patch);

    req.execute(configuration).await
}

/// Update an application.
pub async fn v1_period_application_period_update(configuration: &Configuration, params: V1PeriodApplicationPeriodUpdateParams) -> Result<models::ApplicationOut, Error> {
    // unbox the parameters
    let app_id = params.app_id;
    let application_in = params.application_in;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::PUT, "/api/v1/app/{app_id}".to_string())
    ;
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.with_body_param(application_in);

    req.execute(configuration).await
}

