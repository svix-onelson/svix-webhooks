/*
 * Svix API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.1.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use crate::Configuration;
use crate::models;
use crate::error::Error;
#[allow(unused_imports)]
use crate::models::*;

/// struct for passing parameters to the method [`v1_period_message_attempt_period_count_by_endpoint`]
#[derive(Clone, Debug)]
pub struct V1PeriodMessageAttemptPeriodCountByEndpointParams {
    /// The app's ID or UID
    pub app_id: String,
    /// The ep's ID or UID
    pub endpoint_id: String,
    /// Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
    pub status: Option<MessageStatus>,
    /// Filter response based on the HTTP status code
    pub status_code_class: Option<StatusCodeClass>,
    /// Filter response based on the channel
    pub channel: Option<String>,
    /// Filter response based on the tag
    pub tag: Option<String>,
    /// Only include items created before a certain date
    pub before: Option<String>,
    /// Only include items created after a certain date
    pub after: Option<String>,
    /// Filter response based on the event type
    pub event_types: Option<Vec<String>>
}

/// struct for passing parameters to the method [`v1_period_message_attempt_period_expunge_content`]
#[derive(Clone, Debug)]
pub struct V1PeriodMessageAttemptPeriodExpungeContentParams {
    /// The app's ID or UID
    pub app_id: String,
    /// The msg's ID or UID
    pub msg_id: String,
    /// The attempt's ID
    pub attempt_id: String
}

/// struct for passing parameters to the method [`v1_period_message_attempt_period_get`]
#[derive(Clone, Debug)]
pub struct V1PeriodMessageAttemptPeriodGetParams {
    /// The app's ID or UID
    pub app_id: String,
    /// The msg's ID or UID
    pub msg_id: String,
    /// The attempt's ID
    pub attempt_id: String
}

/// struct for passing parameters to the method [`v1_period_message_attempt_period_get_headers`]
#[derive(Clone, Debug)]
pub struct V1PeriodMessageAttemptPeriodGetHeadersParams {
    /// The app's ID or UID
    pub app_id: String,
    /// The msg's ID or UID
    pub msg_id: String,
    /// The attempt's ID
    pub attempt_id: String
}

/// struct for passing parameters to the method [`v1_period_message_attempt_period_list_attempted_destinations`]
#[derive(Clone, Debug)]
pub struct V1PeriodMessageAttemptPeriodListAttemptedDestinationsParams {
    /// The app's ID or UID
    pub app_id: String,
    /// The msg's ID or UID
    pub msg_id: String,
    /// Limit the number of returned items
    pub limit: Option<i32>,
    /// The iterator returned from a prior invocation
    pub iterator: Option<String>
}

/// struct for passing parameters to the method [`v1_period_message_attempt_period_list_attempted_messages`]
#[derive(Clone, Debug)]
pub struct V1PeriodMessageAttemptPeriodListAttemptedMessagesParams {
    /// The app's ID or UID
    pub app_id: String,
    /// The ep's ID or UID
    pub endpoint_id: String,
    /// Limit the number of returned items
    pub limit: Option<i32>,
    /// The iterator returned from a prior invocation
    pub iterator: Option<String>,
    /// Filter response based on the channel
    pub channel: Option<String>,
    /// Filter response based on the message tags
    pub tag: Option<String>,
    /// Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
    pub status: Option<MessageStatus>,
    /// Only include items created before a certain date
    pub before: Option<String>,
    /// Only include items created after a certain date
    pub after: Option<String>,
    /// When `true` message payloads are included in the response
    pub with_content: Option<bool>,
    /// Filter response based on the event type
    pub event_types: Option<Vec<String>>
}

/// struct for passing parameters to the method [`v1_period_message_attempt_period_list_by_endpoint`]
#[derive(Clone, Debug)]
pub struct V1PeriodMessageAttemptPeriodListByEndpointParams {
    /// The app's ID or UID
    pub app_id: String,
    /// The ep's ID or UID
    pub endpoint_id: String,
    /// Limit the number of returned items
    pub limit: Option<i32>,
    /// The iterator returned from a prior invocation
    pub iterator: Option<String>,
    /// Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
    pub status: Option<MessageStatus>,
    /// Filter response based on the HTTP status code
    pub status_code_class: Option<StatusCodeClass>,
    /// Filter response based on the channel
    pub channel: Option<String>,
    /// Filter response based on the tag
    pub tag: Option<String>,
    /// Only include items created before a certain date
    pub before: Option<String>,
    /// Only include items created after a certain date
    pub after: Option<String>,
    /// When `true` attempt content is included in the response
    pub with_content: Option<bool>,
    /// When `true`, the message information is included in the response
    pub with_msg: Option<bool>,
    /// Filter response based on the event type
    pub event_types: Option<Vec<String>>
}

/// struct for passing parameters to the method [`v1_period_message_attempt_period_list_by_endpoint_deprecated`]
#[derive(Clone, Debug)]
pub struct V1PeriodMessageAttemptPeriodListByEndpointDeprecatedParams {
    /// The app's ID or UID
    pub app_id: String,
    /// The msg's ID or UID
    pub msg_id: String,
    /// The ep's ID or UID
    pub endpoint_id: String,
    /// Limit the number of returned items
    pub limit: Option<i32>,
    /// The iterator returned from a prior invocation
    pub iterator: Option<String>,
    /// Filter response based on the channel
    pub channel: Option<String>,
    /// Filter response based on the tag
    pub tag: Option<String>,
    /// Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
    pub status: Option<MessageStatus>,
    /// Only include items created before a certain date
    pub before: Option<String>,
    /// Only include items created after a certain date
    pub after: Option<String>,
    /// Filter response based on the event type
    pub event_types: Option<Vec<String>>
}

/// struct for passing parameters to the method [`v1_period_message_attempt_period_list_by_msg`]
#[derive(Clone, Debug)]
pub struct V1PeriodMessageAttemptPeriodListByMsgParams {
    /// The app's ID or UID
    pub app_id: String,
    /// The msg's ID or UID
    pub msg_id: String,
    /// Limit the number of returned items
    pub limit: Option<i32>,
    /// The iterator returned from a prior invocation
    pub iterator: Option<String>,
    /// Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
    pub status: Option<MessageStatus>,
    /// Filter response based on the HTTP status code
    pub status_code_class: Option<StatusCodeClass>,
    /// Filter response based on the channel
    pub channel: Option<String>,
    /// Filter response based on the tag
    pub tag: Option<String>,
    /// Filter the attempts based on the attempted endpoint
    pub endpoint_id: Option<String>,
    /// Only include items created before a certain date
    pub before: Option<String>,
    /// Only include items created after a certain date
    pub after: Option<String>,
    /// When `true` attempt content is included in the response
    pub with_content: Option<bool>,
    /// Filter response based on the event type
    pub event_types: Option<Vec<String>>
}

/// struct for passing parameters to the method [`v1_period_message_attempt_period_list_by_msg_deprecated`]
#[derive(Clone, Debug)]
pub struct V1PeriodMessageAttemptPeriodListByMsgDeprecatedParams {
    /// The app's ID or UID
    pub app_id: String,
    /// The msg's ID or UID
    pub msg_id: String,
    /// Limit the number of returned items
    pub limit: Option<i32>,
    /// The iterator returned from a prior invocation
    pub iterator: Option<String>,
    /// Filter the attempts based on the attempted endpoint
    pub endpoint_id: Option<String>,
    /// Filter response based on the channel
    pub channel: Option<String>,
    /// Filter response based on the tag
    pub tag: Option<String>,
    /// Filter response based on the status of the attempt: Success (0), Pending (1), Failed (2), or Sending (3)
    pub status: Option<MessageStatus>,
    /// Only include items created before a certain date
    pub before: Option<String>,
    /// Only include items created after a certain date
    pub after: Option<String>,
    /// Filter response based on the HTTP status code
    pub status_code_class: Option<StatusCodeClass>,
    /// Filter response based on the event type
    pub event_types: Option<Vec<String>>
}

/// struct for passing parameters to the method [`v1_period_message_attempt_period_resend`]
#[derive(Clone, Debug)]
pub struct V1PeriodMessageAttemptPeriodResendParams {
    /// The app's ID or UID
    pub app_id: String,
    /// The msg's ID or UID
    pub msg_id: String,
    /// The ep's ID or UID
    pub endpoint_id: String,
    /// The request's idempotency key
    pub idempotency_key: Option<String>
}


/// struct for typed errors of method [`v1_period_message_attempt_period_count_by_endpoint`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodMessageAttemptPeriodCountByEndpointError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_message_attempt_period_expunge_content`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodMessageAttemptPeriodExpungeContentError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_message_attempt_period_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodMessageAttemptPeriodGetError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_message_attempt_period_get_headers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodMessageAttemptPeriodGetHeadersError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_message_attempt_period_list_attempted_destinations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodMessageAttemptPeriodListAttemptedDestinationsError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_message_attempt_period_list_attempted_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodMessageAttemptPeriodListAttemptedMessagesError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_message_attempt_period_list_by_endpoint`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodMessageAttemptPeriodListByEndpointError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_message_attempt_period_list_by_endpoint_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodMessageAttemptPeriodListByEndpointDeprecatedError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_message_attempt_period_list_by_msg`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodMessageAttemptPeriodListByMsgError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_message_attempt_period_list_by_msg_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodMessageAttemptPeriodListByMsgDeprecatedError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_message_attempt_period_resend`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodMessageAttemptPeriodResendError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}


/// Like `v1.message-attempt.list-by-endpoint` but returning a count only.
pub async fn v1_period_message_attempt_period_count_by_endpoint(configuration: &Configuration, params: V1PeriodMessageAttemptPeriodCountByEndpointParams) -> Result<models::CountOut, Error> {
    // unbox the parameters
    let app_id = params.app_id;
    let endpoint_id = params.endpoint_id;
    let status = params.status;
    let status_code_class = params.status_code_class;
    let channel = params.channel;
    let tag = params.tag;
    let before = params.before;
    let after = params.after;
    let event_types = params.event_types;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/app/{app_id}/attempt/endpoint/{endpoint_id}/count".to_string())
    ;
    if let Some(ref s) = status {
        let query_value = s.to_string();
        req = req.with_query_param("status".to_string(), query_value);
    }
    if let Some(ref s) = status_code_class {
        let query_value = s.to_string();
        req = req.with_query_param("status_code_class".to_string(), query_value);
    }
    if let Some(ref s) = channel {
        let query_value = s.to_string();
        req = req.with_query_param("channel".to_string(), query_value);
    }
    if let Some(ref s) = tag {
        let query_value = s.to_string();
        req = req.with_query_param("tag".to_string(), query_value);
    }
    if let Some(ref s) = before {
        let query_value = s.to_string();
        req = req.with_query_param("before".to_string(), query_value);
    }
    if let Some(ref s) = after {
        let query_value = s.to_string();
        req = req.with_query_param("after".to_string(), query_value);
    }
    if let Some(ref s) = event_types {
        let query_value = s.iter().map(|s| s.to_string()).collect::<Vec<String>>().join(",");
        req = req.with_query_param("event_types".to_string(), query_value);
    }
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.with_path_param("endpoint_id".to_string(), endpoint_id.to_string());

    req.execute(configuration).await
}

/// Deletes the given attempt's response body.  Useful when an endpoint accidentally returned sensitive content. The message can't be replayed or resent once its payload has been deleted or expired.
pub async fn v1_period_message_attempt_period_expunge_content(configuration: &Configuration, params: V1PeriodMessageAttemptPeriodExpungeContentParams) -> Result<(), Error> {
    // unbox the parameters
    let app_id = params.app_id;
    let msg_id = params.msg_id;
    let attempt_id = params.attempt_id;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::DELETE, "/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}/content".to_string())
    ;
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.with_path_param("msg_id".to_string(), msg_id.to_string());
    req = req.with_path_param("attempt_id".to_string(), attempt_id.to_string());
    req = req.returns_nothing();

    req.execute(configuration).await
}

/// `msg_id`: Use a message id or a message `eventId`
pub async fn v1_period_message_attempt_period_get(configuration: &Configuration, params: V1PeriodMessageAttemptPeriodGetParams) -> Result<models::MessageAttemptOut, Error> {
    // unbox the parameters
    let app_id = params.app_id;
    let msg_id = params.msg_id;
    let attempt_id = params.attempt_id;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}".to_string())
    ;
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.with_path_param("msg_id".to_string(), msg_id.to_string());
    req = req.with_path_param("attempt_id".to_string(), attempt_id.to_string());

    req.execute(configuration).await
}

/// Calculate and return headers used on a given message attempt
pub async fn v1_period_message_attempt_period_get_headers(configuration: &Configuration, params: V1PeriodMessageAttemptPeriodGetHeadersParams) -> Result<models::MessageAttemptHeadersOut, Error> {
    // unbox the parameters
    let app_id = params.app_id;
    let msg_id = params.msg_id;
    let attempt_id = params.attempt_id;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}/headers".to_string())
    ;
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.with_path_param("msg_id".to_string(), msg_id.to_string());
    req = req.with_path_param("attempt_id".to_string(), attempt_id.to_string());

    req.execute(configuration).await
}

/// List endpoints attempted by a given message.  Additionally includes metadata about the latest message attempt. By default, endpoints are listed in ascending order by ID.
pub async fn v1_period_message_attempt_period_list_attempted_destinations(configuration: &Configuration, params: V1PeriodMessageAttemptPeriodListAttemptedDestinationsParams) -> Result<models::ListResponseMessageEndpointOut, Error> {
    // unbox the parameters
    let app_id = params.app_id;
    let msg_id = params.msg_id;
    let limit = params.limit;
    let iterator = params.iterator;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/app/{app_id}/msg/{msg_id}/endpoint".to_string())
    ;
    if let Some(ref s) = limit {
        let query_value = s.to_string();
        req = req.with_query_param("limit".to_string(), query_value);
    }
    if let Some(ref s) = iterator {
        let query_value = s.to_string();
        req = req.with_query_param("iterator".to_string(), query_value);
    }
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.with_path_param("msg_id".to_string(), msg_id.to_string());

    req.execute(configuration).await
}

/// List messages for a particular endpoint. Additionally includes metadata about the latest message attempt.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.  Note that by default this endpoint is limited to retrieving 90 days' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
pub async fn v1_period_message_attempt_period_list_attempted_messages(configuration: &Configuration, params: V1PeriodMessageAttemptPeriodListAttemptedMessagesParams) -> Result<models::ListResponseEndpointMessageOut, Error> {
    // unbox the parameters
    let app_id = params.app_id;
    let endpoint_id = params.endpoint_id;
    let limit = params.limit;
    let iterator = params.iterator;
    let channel = params.channel;
    let tag = params.tag;
    let status = params.status;
    let before = params.before;
    let after = params.after;
    let with_content = params.with_content;
    let event_types = params.event_types;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/msg".to_string())
    ;
    if let Some(ref s) = limit {
        let query_value = s.to_string();
        req = req.with_query_param("limit".to_string(), query_value);
    }
    if let Some(ref s) = iterator {
        let query_value = s.to_string();
        req = req.with_query_param("iterator".to_string(), query_value);
    }
    if let Some(ref s) = channel {
        let query_value = s.to_string();
        req = req.with_query_param("channel".to_string(), query_value);
    }
    if let Some(ref s) = tag {
        let query_value = s.to_string();
        req = req.with_query_param("tag".to_string(), query_value);
    }
    if let Some(ref s) = status {
        let query_value = s.to_string();
        req = req.with_query_param("status".to_string(), query_value);
    }
    if let Some(ref s) = before {
        let query_value = s.to_string();
        req = req.with_query_param("before".to_string(), query_value);
    }
    if let Some(ref s) = after {
        let query_value = s.to_string();
        req = req.with_query_param("after".to_string(), query_value);
    }
    if let Some(ref s) = with_content {
        let query_value = s.to_string();
        req = req.with_query_param("with_content".to_string(), query_value);
    }
    if let Some(ref s) = event_types {
        let query_value = s.iter().map(|s| s.to_string()).collect::<Vec<String>>().join(",");
        req = req.with_query_param("event_types".to_string(), query_value);
    }
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.with_path_param("endpoint_id".to_string(), endpoint_id.to_string());

    req.execute(configuration).await
}

/// List attempts by endpoint id  Note that by default this endpoint is limited to retrieving 90 days' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
pub async fn v1_period_message_attempt_period_list_by_endpoint(configuration: &Configuration, params: V1PeriodMessageAttemptPeriodListByEndpointParams) -> Result<models::ListResponseMessageAttemptOut, Error> {
    // unbox the parameters
    let app_id = params.app_id;
    let endpoint_id = params.endpoint_id;
    let limit = params.limit;
    let iterator = params.iterator;
    let status = params.status;
    let status_code_class = params.status_code_class;
    let channel = params.channel;
    let tag = params.tag;
    let before = params.before;
    let after = params.after;
    let with_content = params.with_content;
    let with_msg = params.with_msg;
    let event_types = params.event_types;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/app/{app_id}/attempt/endpoint/{endpoint_id}".to_string())
    ;
    if let Some(ref s) = limit {
        let query_value = s.to_string();
        req = req.with_query_param("limit".to_string(), query_value);
    }
    if let Some(ref s) = iterator {
        let query_value = s.to_string();
        req = req.with_query_param("iterator".to_string(), query_value);
    }
    if let Some(ref s) = status {
        let query_value = s.to_string();
        req = req.with_query_param("status".to_string(), query_value);
    }
    if let Some(ref s) = status_code_class {
        let query_value = s.to_string();
        req = req.with_query_param("status_code_class".to_string(), query_value);
    }
    if let Some(ref s) = channel {
        let query_value = s.to_string();
        req = req.with_query_param("channel".to_string(), query_value);
    }
    if let Some(ref s) = tag {
        let query_value = s.to_string();
        req = req.with_query_param("tag".to_string(), query_value);
    }
    if let Some(ref s) = before {
        let query_value = s.to_string();
        req = req.with_query_param("before".to_string(), query_value);
    }
    if let Some(ref s) = after {
        let query_value = s.to_string();
        req = req.with_query_param("after".to_string(), query_value);
    }
    if let Some(ref s) = with_content {
        let query_value = s.to_string();
        req = req.with_query_param("with_content".to_string(), query_value);
    }
    if let Some(ref s) = with_msg {
        let query_value = s.to_string();
        req = req.with_query_param("with_msg".to_string(), query_value);
    }
    if let Some(ref s) = event_types {
        let query_value = s.iter().map(|s| s.to_string()).collect::<Vec<String>>().join(",");
        req = req.with_query_param("event_types".to_string(), query_value);
    }
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.with_path_param("endpoint_id".to_string(), endpoint_id.to_string());

    req.execute(configuration).await
}

/// DEPRECATED: please use list_attempts with endpoint_id as a query parameter instead.  List the message attempts for a particular endpoint.  Returning the endpoint.  The `before` parameter lets you filter all items created before a certain date and is ignored if an iterator is passed.  Note that by default this endpoint is limited to retrieving 90 days' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate. 
pub async fn v1_period_message_attempt_period_list_by_endpoint_deprecated(configuration: &Configuration, params: V1PeriodMessageAttemptPeriodListByEndpointDeprecatedParams) -> Result<models::ListResponseMessageAttemptEndpointOut, Error> {
    // unbox the parameters
    let app_id = params.app_id;
    let msg_id = params.msg_id;
    let endpoint_id = params.endpoint_id;
    let limit = params.limit;
    let iterator = params.iterator;
    let channel = params.channel;
    let tag = params.tag;
    let status = params.status;
    let before = params.before;
    let after = params.after;
    let event_types = params.event_types;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/attempt".to_string())
    ;
    if let Some(ref s) = limit {
        let query_value = s.to_string();
        req = req.with_query_param("limit".to_string(), query_value);
    }
    if let Some(ref s) = iterator {
        let query_value = s.to_string();
        req = req.with_query_param("iterator".to_string(), query_value);
    }
    if let Some(ref s) = channel {
        let query_value = s.to_string();
        req = req.with_query_param("channel".to_string(), query_value);
    }
    if let Some(ref s) = tag {
        let query_value = s.to_string();
        req = req.with_query_param("tag".to_string(), query_value);
    }
    if let Some(ref s) = status {
        let query_value = s.to_string();
        req = req.with_query_param("status".to_string(), query_value);
    }
    if let Some(ref s) = before {
        let query_value = s.to_string();
        req = req.with_query_param("before".to_string(), query_value);
    }
    if let Some(ref s) = after {
        let query_value = s.to_string();
        req = req.with_query_param("after".to_string(), query_value);
    }
    if let Some(ref s) = event_types {
        let query_value = s.iter().map(|s| s.to_string()).collect::<Vec<String>>().join(",");
        req = req.with_query_param("event_types".to_string(), query_value);
    }
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.with_path_param("msg_id".to_string(), msg_id.to_string());
    req = req.with_path_param("endpoint_id".to_string(), endpoint_id.to_string());

    req.execute(configuration).await
}

/// List attempts by message ID.  Note that by default this endpoint is limited to retrieving 90 days' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate.
pub async fn v1_period_message_attempt_period_list_by_msg(configuration: &Configuration, params: V1PeriodMessageAttemptPeriodListByMsgParams) -> Result<models::ListResponseMessageAttemptOut, Error> {
    // unbox the parameters
    let app_id = params.app_id;
    let msg_id = params.msg_id;
    let limit = params.limit;
    let iterator = params.iterator;
    let status = params.status;
    let status_code_class = params.status_code_class;
    let channel = params.channel;
    let tag = params.tag;
    let endpoint_id = params.endpoint_id;
    let before = params.before;
    let after = params.after;
    let with_content = params.with_content;
    let event_types = params.event_types;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/app/{app_id}/attempt/msg/{msg_id}".to_string())
    ;
    if let Some(ref s) = limit {
        let query_value = s.to_string();
        req = req.with_query_param("limit".to_string(), query_value);
    }
    if let Some(ref s) = iterator {
        let query_value = s.to_string();
        req = req.with_query_param("iterator".to_string(), query_value);
    }
    if let Some(ref s) = status {
        let query_value = s.to_string();
        req = req.with_query_param("status".to_string(), query_value);
    }
    if let Some(ref s) = status_code_class {
        let query_value = s.to_string();
        req = req.with_query_param("status_code_class".to_string(), query_value);
    }
    if let Some(ref s) = channel {
        let query_value = s.to_string();
        req = req.with_query_param("channel".to_string(), query_value);
    }
    if let Some(ref s) = tag {
        let query_value = s.to_string();
        req = req.with_query_param("tag".to_string(), query_value);
    }
    if let Some(ref s) = endpoint_id {
        let query_value = s.to_string();
        req = req.with_query_param("endpoint_id".to_string(), query_value);
    }
    if let Some(ref s) = before {
        let query_value = s.to_string();
        req = req.with_query_param("before".to_string(), query_value);
    }
    if let Some(ref s) = after {
        let query_value = s.to_string();
        req = req.with_query_param("after".to_string(), query_value);
    }
    if let Some(ref s) = with_content {
        let query_value = s.to_string();
        req = req.with_query_param("with_content".to_string(), query_value);
    }
    if let Some(ref s) = event_types {
        let query_value = s.iter().map(|s| s.to_string()).collect::<Vec<String>>().join(",");
        req = req.with_query_param("event_types".to_string(), query_value);
    }
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.with_path_param("msg_id".to_string(), msg_id.to_string());

    req.execute(configuration).await
}

/// Deprecated: Please use \"List Attempts by Endpoint\" and \"List Attempts by Msg\" instead.  Note that by default this endpoint is limited to retrieving 90 days' worth of data relative to now or, if an iterator is provided, 90 days before/after the time indicated by the iterator ID. If you require data beyond those time ranges, you will need to explicitly set the `before` or `after` parameter as appropriate.  `msg_id`: Use a message id or a message `eventId`
pub async fn v1_period_message_attempt_period_list_by_msg_deprecated(configuration: &Configuration, params: V1PeriodMessageAttemptPeriodListByMsgDeprecatedParams) -> Result<models::ListResponseMessageAttemptOut, Error> {
    // unbox the parameters
    let app_id = params.app_id;
    let msg_id = params.msg_id;
    let limit = params.limit;
    let iterator = params.iterator;
    let endpoint_id = params.endpoint_id;
    let channel = params.channel;
    let tag = params.tag;
    let status = params.status;
    let before = params.before;
    let after = params.after;
    let status_code_class = params.status_code_class;
    let event_types = params.event_types;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/app/{app_id}/msg/{msg_id}/attempt".to_string())
    ;
    if let Some(ref s) = limit {
        let query_value = s.to_string();
        req = req.with_query_param("limit".to_string(), query_value);
    }
    if let Some(ref s) = iterator {
        let query_value = s.to_string();
        req = req.with_query_param("iterator".to_string(), query_value);
    }
    if let Some(ref s) = endpoint_id {
        let query_value = s.to_string();
        req = req.with_query_param("endpoint_id".to_string(), query_value);
    }
    if let Some(ref s) = channel {
        let query_value = s.to_string();
        req = req.with_query_param("channel".to_string(), query_value);
    }
    if let Some(ref s) = tag {
        let query_value = s.to_string();
        req = req.with_query_param("tag".to_string(), query_value);
    }
    if let Some(ref s) = status {
        let query_value = s.to_string();
        req = req.with_query_param("status".to_string(), query_value);
    }
    if let Some(ref s) = before {
        let query_value = s.to_string();
        req = req.with_query_param("before".to_string(), query_value);
    }
    if let Some(ref s) = after {
        let query_value = s.to_string();
        req = req.with_query_param("after".to_string(), query_value);
    }
    if let Some(ref s) = status_code_class {
        let query_value = s.to_string();
        req = req.with_query_param("status_code_class".to_string(), query_value);
    }
    if let Some(ref s) = event_types {
        let query_value = s.iter().map(|s| s.to_string()).collect::<Vec<String>>().join(",");
        req = req.with_query_param("event_types".to_string(), query_value);
    }
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.with_path_param("msg_id".to_string(), msg_id.to_string());

    req.execute(configuration).await
}

/// Resend a message to the specified endpoint.
pub async fn v1_period_message_attempt_period_resend(configuration: &Configuration, params: V1PeriodMessageAttemptPeriodResendParams) -> Result<(), Error> {
    // unbox the parameters
    let app_id = params.app_id;
    let msg_id = params.msg_id;
    let endpoint_id = params.endpoint_id;
    let idempotency_key = params.idempotency_key;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::POST, "/api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/resend".to_string())
    ;
    req = req.with_path_param("app_id".to_string(), app_id.to_string());
    req = req.with_path_param("msg_id".to_string(), msg_id.to_string());
    req = req.with_path_param("endpoint_id".to_string(), endpoint_id.to_string());
    if let Some(param_value) = idempotency_key {
        req = req.with_header_param("idempotency-key".to_string(), param_value.to_string());
    }
    req = req.returns_nothing();

    req.execute(configuration).await
}

