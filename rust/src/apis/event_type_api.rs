/*
 * Svix API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.1.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use crate::Configuration;
use crate::models;
use crate::error::Error;
#[allow(unused_imports)]
use crate::models::*;

/// struct for passing parameters to the method [`v1_period_event_type_period_create`]
#[derive(Clone, Debug)]
pub struct V1PeriodEventTypePeriodCreateParams {
    pub event_type_in: models::EventTypeIn,
    /// The request's idempotency key
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`v1_period_event_type_period_delete`]
#[derive(Clone, Debug)]
pub struct V1PeriodEventTypePeriodDeleteParams {
    /// The event type's name
    pub event_type_name: String,
    /// By default event types are archived when \"deleted\". Passing this to `true` deletes them entirely.
    pub expunge: Option<bool>
}

/// struct for passing parameters to the method [`v1_period_event_type_period_export_openapi`]
#[derive(Clone, Debug)]
pub struct V1PeriodEventTypePeriodExportOpenapiParams {
    /// The request's idempotency key
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`v1_period_event_type_period_generate_example`]
#[derive(Clone, Debug)]
pub struct V1PeriodEventTypePeriodGenerateExampleParams {
    pub event_type_schema_in: models::EventTypeSchemaIn,
    /// The request's idempotency key
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`v1_period_event_type_period_get`]
#[derive(Clone, Debug)]
pub struct V1PeriodEventTypePeriodGetParams {
    /// The event type's name
    pub event_type_name: String
}

/// struct for passing parameters to the method [`v1_period_event_type_period_get_retry_schedule`]
#[derive(Clone, Debug)]
pub struct V1PeriodEventTypePeriodGetRetryScheduleParams {
    /// The event type's name
    pub event_type_name: String
}

/// struct for passing parameters to the method [`v1_period_event_type_period_import_openapi`]
#[derive(Clone, Debug)]
pub struct V1PeriodEventTypePeriodImportOpenapiParams {
    /// Import a list of event types from webhooks defined in an OpenAPI spec.  The OpenAPI spec can be specified as either `spec` given the spec as a JSON object, or as `specRaw` (a `string`) which will be parsed as YAML or JSON by the server. Sending neither or both is invalid, resulting in a `400` **Bad Request**.
    pub event_type_import_open_api_in: models::EventTypeImportOpenApiIn,
    /// The request's idempotency key
    pub idempotency_key: Option<String>
}

/// struct for passing parameters to the method [`v1_period_event_type_period_list`]
#[derive(Clone, Debug)]
pub struct V1PeriodEventTypePeriodListParams {
    /// Limit the number of returned items
    pub limit: Option<i32>,
    /// The iterator returned from a prior invocation
    pub iterator: Option<String>,
    /// The sorting order of the returned items
    pub order: Option<Ordering>,
    /// When `true` archived (deleted but not expunged) items are included in the response.
    pub include_archived: Option<bool>,
    /// When `true` the full item (including the schema) is included in the response.
    pub with_content: Option<bool>
}

/// struct for passing parameters to the method [`v1_period_event_type_period_patch`]
#[derive(Clone, Debug)]
pub struct V1PeriodEventTypePeriodPatchParams {
    /// The event type's name
    pub event_type_name: String,
    pub event_type_patch: models::EventTypePatch
}

/// struct for passing parameters to the method [`v1_period_event_type_period_update`]
#[derive(Clone, Debug)]
pub struct V1PeriodEventTypePeriodUpdateParams {
    /// The event type's name
    pub event_type_name: String,
    pub event_type_update: models::EventTypeUpdate
}

/// struct for passing parameters to the method [`v1_period_event_type_period_update_retry_schedule`]
#[derive(Clone, Debug)]
pub struct V1PeriodEventTypePeriodUpdateRetryScheduleParams {
    /// The event type's name
    pub event_type_name: String,
    pub retry_schedule_in_out: models::RetryScheduleInOut
}


/// struct for typed errors of method [`v1_period_event_type_period_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodEventTypePeriodCreateError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_event_type_period_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodEventTypePeriodDeleteError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_event_type_period_export_openapi`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodEventTypePeriodExportOpenapiError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_event_type_period_generate_example`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodEventTypePeriodGenerateExampleError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_event_type_period_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodEventTypePeriodGetError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_event_type_period_get_retry_schedule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodEventTypePeriodGetRetryScheduleError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_event_type_period_import_openapi`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodEventTypePeriodImportOpenapiError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_event_type_period_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodEventTypePeriodListError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_event_type_period_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodEventTypePeriodPatchError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_event_type_period_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodEventTypePeriodUpdateError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_period_event_type_period_update_retry_schedule`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodEventTypePeriodUpdateRetryScheduleError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}


/// Create new or unarchive existing event type.  Unarchiving an event type will allow endpoints to filter on it and messages to be sent with it. Endpoints filtering on the event type before archival will continue to filter on it. This operation does not preserve the description and schemas.
pub async fn v1_period_event_type_period_create(configuration: &Configuration, params: V1PeriodEventTypePeriodCreateParams) -> Result<models::EventTypeOut, Error> {
    // unbox the parameters
    let event_type_in = params.event_type_in;
    let idempotency_key = params.idempotency_key;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::POST, "/api/v1/event-type".to_string())
    ;
    if let Some(param_value) = idempotency_key {
        req = req.with_header_param("idempotency-key".to_string(), param_value.to_string());
    }
    req = req.with_body_param(event_type_in);

    req.execute(configuration).await
}

/// Archive an event type.  Endpoints already configured to filter on an event type will continue to do so after archival. However, new messages can not be sent with it and endpoints can not filter on it. An event type can be unarchived with the [create operation](#operation/create_event_type_api_v1_event_type__post).
pub async fn v1_period_event_type_period_delete(configuration: &Configuration, params: V1PeriodEventTypePeriodDeleteParams) -> Result<(), Error> {
    // unbox the parameters
    let event_type_name = params.event_type_name;
    let expunge = params.expunge;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::DELETE, "/api/v1/event-type/{event_type_name}".to_string())
    ;
    if let Some(ref s) = expunge {
        let query_value = s.to_string();
        req = req.with_query_param("expunge".to_string(), query_value);
    }
    req = req.with_path_param("event_type_name".to_string(), event_type_name.to_string());
    req = req.returns_nothing();

    req.execute(configuration).await
}

/// Exports event type definitions based on the OpenAPI schemas associated with each existing event type.
pub async fn v1_period_event_type_period_export_openapi(configuration: &Configuration, params: V1PeriodEventTypePeriodExportOpenapiParams) -> Result<models::ExportEventTypeOut, Error> {
    // unbox the parameters
    let idempotency_key = params.idempotency_key;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::POST, "/api/v1/event-type/export/openapi".to_string())
    ;
    if let Some(param_value) = idempotency_key {
        req = req.with_header_param("idempotency-key".to_string(), param_value.to_string());
    }

    req.execute(configuration).await
}

/// Generates a fake example from the given JSONSchema.
pub async fn v1_period_event_type_period_generate_example(configuration: &Configuration, params: V1PeriodEventTypePeriodGenerateExampleParams) -> Result<models::EventTypeExampleOut, Error> {
    // unbox the parameters
    let event_type_schema_in = params.event_type_schema_in;
    let idempotency_key = params.idempotency_key;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::POST, "/api/v1/event-type/schema/generate-example".to_string())
    ;
    if let Some(param_value) = idempotency_key {
        req = req.with_header_param("idempotency-key".to_string(), param_value.to_string());
    }
    req = req.with_body_param(event_type_schema_in);

    req.execute(configuration).await
}

/// Get an event type.
pub async fn v1_period_event_type_period_get(configuration: &Configuration, params: V1PeriodEventTypePeriodGetParams) -> Result<models::EventTypeOut, Error> {
    // unbox the parameters
    let event_type_name = params.event_type_name;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/event-type/{event_type_name}".to_string())
    ;
    req = req.with_path_param("event_type_name".to_string(), event_type_name.to_string());

    req.execute(configuration).await
}

/// Gets the retry schedule for messages using the given event type.
pub async fn v1_period_event_type_period_get_retry_schedule(configuration: &Configuration, params: V1PeriodEventTypePeriodGetRetryScheduleParams) -> Result<models::RetryScheduleInOut, Error> {
    // unbox the parameters
    let event_type_name = params.event_type_name;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/event-type/{event_type_name}/retry-schedule".to_string())
    ;
    req = req.with_path_param("event_type_name".to_string(), event_type_name.to_string());

    req.execute(configuration).await
}

/// Given an OpenAPI spec, create new or update existing event types. If an existing `archived` event type is updated, it will be unarchived.  The importer will convert all webhooks found in the either the `webhooks` or `x-webhooks` top-level.
pub async fn v1_period_event_type_period_import_openapi(configuration: &Configuration, params: V1PeriodEventTypePeriodImportOpenapiParams) -> Result<models::EventTypeImportOpenApiOut, Error> {
    // unbox the parameters
    let event_type_import_open_api_in = params.event_type_import_open_api_in;
    let idempotency_key = params.idempotency_key;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::POST, "/api/v1/event-type/import/openapi".to_string())
    ;
    if let Some(param_value) = idempotency_key {
        req = req.with_header_param("idempotency-key".to_string(), param_value.to_string());
    }
    req = req.with_body_param(event_type_import_open_api_in);

    req.execute(configuration).await
}

/// Return the list of event types.
pub async fn v1_period_event_type_period_list(configuration: &Configuration, params: V1PeriodEventTypePeriodListParams) -> Result<models::ListResponseEventTypeOut, Error> {
    // unbox the parameters
    let limit = params.limit;
    let iterator = params.iterator;
    let order = params.order;
    let include_archived = params.include_archived;
    let with_content = params.with_content;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/event-type".to_string())
    ;
    if let Some(ref s) = limit {
        let query_value = s.to_string();
        req = req.with_query_param("limit".to_string(), query_value);
    }
    if let Some(ref s) = iterator {
        let query_value = s.to_string();
        req = req.with_query_param("iterator".to_string(), query_value);
    }
    if let Some(ref s) = order {
        let query_value = s.to_string();
        req = req.with_query_param("order".to_string(), query_value);
    }
    if let Some(ref s) = include_archived {
        let query_value = s.to_string();
        req = req.with_query_param("include_archived".to_string(), query_value);
    }
    if let Some(ref s) = with_content {
        let query_value = s.to_string();
        req = req.with_query_param("with_content".to_string(), query_value);
    }

    req.execute(configuration).await
}

/// Partially update an event type.
pub async fn v1_period_event_type_period_patch(configuration: &Configuration, params: V1PeriodEventTypePeriodPatchParams) -> Result<models::EventTypeOut, Error> {
    // unbox the parameters
    let event_type_name = params.event_type_name;
    let event_type_patch = params.event_type_patch;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::PATCH, "/api/v1/event-type/{event_type_name}".to_string())
    ;
    req = req.with_path_param("event_type_name".to_string(), event_type_name.to_string());
    req = req.with_body_param(event_type_patch);

    req.execute(configuration).await
}

/// Update an event type.
pub async fn v1_period_event_type_period_update(configuration: &Configuration, params: V1PeriodEventTypePeriodUpdateParams) -> Result<models::EventTypeOut, Error> {
    // unbox the parameters
    let event_type_name = params.event_type_name;
    let event_type_update = params.event_type_update;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::PUT, "/api/v1/event-type/{event_type_name}".to_string())
    ;
    req = req.with_path_param("event_type_name".to_string(), event_type_name.to_string());
    req = req.with_body_param(event_type_update);

    req.execute(configuration).await
}

/// Sets a retry schedule for all messages using the given event type.
pub async fn v1_period_event_type_period_update_retry_schedule(configuration: &Configuration, params: V1PeriodEventTypePeriodUpdateRetryScheduleParams) -> Result<models::RetryScheduleInOut, Error> {
    // unbox the parameters
    let event_type_name = params.event_type_name;
    let retry_schedule_in_out = params.retry_schedule_in_out;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::PUT, "/api/v1/event-type/{event_type_name}/retry-schedule".to_string())
    ;
    req = req.with_path_param("event_type_name".to_string(), event_type_name.to_string());
    req = req.with_body_param(retry_schedule_in_out);

    req.execute(configuration).await
}

