/*
 * Svix API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.1.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use crate::Configuration;
use crate::models;
use crate::error::Error;
#[allow(unused_imports)]
use crate::models::*;

/// struct for passing parameters to the method [`v1_period_events`]
#[derive(Clone, Debug)]
pub struct V1PeriodEventsParams {
    /// Limit the number of returned items
    pub limit: Option<i32>,
    /// The iterator returned from a prior invocation
    pub iterator: Option<String>,
    /// Filter response based on the event type
    pub event_types: Option<Vec<String>>,
    /// Filter response based on the event type.
    pub channels: Option<Vec<String>>,
    pub after: Option<String>
}


/// struct for typed errors of method [`v1_period_events`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1PeriodEventsError {
    Status400(models::HttpErrorOut),
    Status401(models::HttpErrorOut),
    Status403(models::HttpErrorOut),
    Status404(models::HttpErrorOut),
    Status409(models::HttpErrorOut),
    Status422(models::HttpValidationError),
    Status429(models::HttpErrorOut),
    UnknownValue(serde_json::Value),
}


/// Reads the stream of operational webhook events for this environment.
pub async fn v1_period_events(configuration: &Configuration, params: V1PeriodEventsParams) -> Result<models::MessageEventsOut, Error> {
    // unbox the parameters
    let limit = params.limit;
    let iterator = params.iterator;
    let event_types = params.event_types;
    let channels = params.channels;
    let after = params.after;


    #[allow(unused_mut)]
    let mut req = crate::request::Request::new(http1::Method::GET, "/api/v1/events".to_string())
    ;
    if let Some(ref s) = limit {
        let query_value = s.to_string();
        req = req.with_query_param("limit".to_string(), query_value);
    }
    if let Some(ref s) = iterator {
        let query_value = s.to_string();
        req = req.with_query_param("iterator".to_string(), query_value);
    }
    if let Some(ref s) = event_types {
        let query_value = s.iter().map(|s| s.to_string()).collect::<Vec<String>>().join(",");
        req = req.with_query_param("event_types".to_string(), query_value);
    }
    if let Some(ref s) = channels {
        let query_value = s.iter().map(|s| s.to_string()).collect::<Vec<String>>().join(",");
        req = req.with_query_param("channels".to_string(), query_value);
    }
    if let Some(ref s) = after {
        let query_value = s.to_string();
        req = req.with_query_param("after".to_string(), query_value);
    }

    req.execute(configuration).await
}

